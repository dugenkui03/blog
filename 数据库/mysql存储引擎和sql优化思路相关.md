##### .数据库MyIsam和Innodb的区别

锁粒度：行锁、间隙锁，表锁。

锁类型：读锁不可写；写锁：不可读写。

Innodb支持事务(begin、commit、rollback，四中默认隔离级别)，支持行锁，修改操作性能好，不保存表记录的数量，支持外键。

（1）事务处理：

MyISAM是非事务安全型的，而InnoDB是事务安全型的（支持事务处理等高级处理）事务用来管理 insert,update,delete 语句。

 BEGIN, ROLLBACK, COMMIT。

（2）锁机制不同：

MyISAM是表级锁，而InnoDB是行级锁；

（3）select ,update ,insert ,delete 操作：

MyISAM：如果执行大量的SELECT，MyISAM是更好的选择
InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表

（4）查询表的行数不同：

MyISAM：`select count(\*) from table`,MyISAM只要简单的读出保存好的行数；

InnoDB ： 执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行。

**count(\*)语句包含   where条件时，两种表的操作是一样的**。

（5）外键支持：
mysiam表不支持外键，而InnoDB支持

#### 一.InnoDB

##### 1.1 引言

InnoDB默认隔离级别是可重复度，即在一个事务内对同一项数据多次读取结果都是相同的，而且InnoDB通过**间隙锁**防止幻读的出现——==InnoDB不仅锁定查询涉及的行，而且会对索引中间的间隙进行锁定，以防止幻影行的插入==。比如事务中查询了x_num在[1,50]之间的40条数据，此时其他事务不能插入x_num在[1,50]的数据。

InnoDB采用MVCC(多版本并发控制)支持高并发。

##### 1.2 聚簇索引

InnoDB表是基于**聚簇索引**建立的，默认通过主键聚集数据，如果没有主键则通过unique键聚集数据，或在创建隐形的主键。

<font color=red>**聚簇索引是数据存储方式，即被选择作为聚簇索引的索引在同一个结构中保存了B-Tree的索引和数据行**。</font>聚簇表示数据行和相邻的键值紧凑的放在一起，因此无法把数据行放在两个不同的地方，因此一个表只能有一个聚簇索引。

聚簇索引对主键(聚簇索引)查询有很高的性能，其非主键索引必须包含主键列，因此如果主键列很大的话，的索引列都会很大。

###### 聚簇索引的数据分布

![](https://wx3.sinaimg.cn/mw1024/006Xp67Kly1fqz7rwaw6aj30oc0ihdjv.jpg)

- 叶子页包含了所有的数据(id、first_name、last_name、bir_day),节点页只包含索引页。

聚簇索引优点：
1. 可以把相关数据放在一起：比如电子邮箱的实现，使用用户id把每个用户的所有数据聚集在一起，这样从磁盘中读取很少的页就能获取用户全部的收发邮件；
2. 数据访问快：聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中取值比其他索引查找取值要快；
3. “使用覆盖索引扫描的查询可以直接使用页节点中的主键值”。

###### 聚簇索引的二级索引和MyISAM索引对比

- 二级索引存放的叶节点存放的是主键值，以其作为指向行的指针(二级索引也存放了索引列的值):
![](https://wx1.sinaimg.cn/mw1024/006Xp67Kly1fqz9yv1lckj30o109n75s.jpg)


- 如上图所示，聚簇索引的二级索引也必须通过主键找到指定行取数据(如果不是覆盖索引的话)。而非聚簇索引则索引的页节点都存放着行指针。
![](https://wx4.sinaimg.cn/mw1024/006Xp67Kly1fqz9zg1yjmj30og0jrq7h.jpg)

#### 二.sql优化思路

##### 2.1 基本知识

b-tree意味着所有的值都是按照顺序进行存储的，所以**很适合查找范围数据**，而且每一个叶子到根的距离是相等的。


##### 2.2 sql优化思路

1. 复合索引是最左优先匹配的；

2. like也可以走到索引，列匹配前缀；

3. 复合索引某个列匹配范围后，后续列将走不到索引，此时可以使用等效的多值代替范围><；

4. 如果索引列包括查询字段，那么讲不用在通过主键找到指定行取值，速度将更快，即走到了==覆盖索引==；
5. 延迟关联:让符合索引包括主键，这样不用查到叶节点就可以找到主键，详细见最后示例；
6. 如果有一列区分度很小但是业务中经常用到，就可以设置为枚举类型，然后每次查询都用到，如果不需要使用的话就用in(a,b,c..)做等值查询；
7. 索引很长的字符列会导致索引变得很大很慢，可以使用`later table t_name add key(col_name(5))`创建指定长度的前缀索引。如果想要创建“后缀索引”则直接你出存储然后创建前缀索引即可。前缀多长可以参考`select count(distinct left(col_name,x))/count(*) from tab_name`，如果随着x的增大值不在变大太多，则前缀长度为x；
8. 使用explain查看查询计划。
9. 不用的列不查询；不适用select *;
10. 为了防止锁表可以使用id做切分查询；
11. 使用limit限制查询结果数量；
12. 开启缓存，并且严格限制每个客户端的sql书写方式——空格都会导致不命中；
13. 分解关联查询：提高缓存命中率，减少锁的竞争。




###### 排序优化思路

 `order by`和`group by`操作同where一样，也可以走到索引。但是：
 ```
 比如表中有索引(a,b,c):
//order by和where既可以走到一个索引，也可以走到两个索引但是一个索引时比较快；
//索引列的和order by顺序完全一致，而且列的排序方向(desc  asc)为升序时，才可以使用索引对结果进行排序；

下行排序不能走到索引，因为列排序方向不升序
select a,b,c from tab_name tn
where a='xx'
order by b desc,c asc;

//最左匹配：order by子句不满足索引最前匹配原则也可以用于查询排序，如果索引的第一列是常量
select a,b,c from table_name tn
where a='x'
order by b,c

b,c与索引(a,b,c)不一致，但是第一列是常量值，ok。order字段没有c也遵守了最左匹配，可以走到索引。

select a,b,c from table_name tn
where a>'x'
order by a,b

也可以走到索引，但是where和order走到两次索引。

注意最左匹配原则是，如果order字段有复合索引之外或者有间隔的字段都无法走到索引。坏实例如下：

上边实例中某排序列desc修饰的；

... where a='x'
order by b,d -- 使用了非索引字段

... where a='x'
order by c -- 无法使用最左匹配

... where a>'x'
order by b,c -- 无法最左匹配，wher也不是常量

... where a='x'
order by b in (b1,b2) c -- in对order来说是范围，无法多值相等匹配。



//如果order by涉及多张表，则索引走到的字段只能是ordre第一个字段所在表的字段；
；
```


###### 加锁过程

synchronized代码块被编译成monitorenter和monitorexit两个指令，**线程执行到monitorenter指令时，会尝试获取对象监视器的所有权，即尝试获取锁，失败则阻塞**。

如果是synchronized方法，则会在方法的access_flags标识`ACC_SYNCHRONIZED`,表示使用该方法需要获取方法对象的锁或是发放所述类class对象的锁。

每个对象都有与之对应的监视器。

###### 锁

synchronized用的锁在对象头中。

对象头2个字(或再加一个数组长度）：

1. **mark word**：对象hashCode、GC年龄和**锁信息**；


随着加锁的不同，mark可能有如下三种状态：

```
无锁状态；

只有一个线程使用锁：
偏向锁01：线程id，是否是可偏向0/1——对象监视器降级后，不在可偏向；

虽然有多个线程使用锁，但是使用锁的周期内不存在竞争：
轻量级锁00：指向栈帧中锁记录的指针；

重量级锁10：指向互斥量的指针；

```

**偏向锁和轻量级锁**是为了减少加锁释放锁带来的性能消耗；

###### 偏向锁：一个线程使用的情况

**消除锁在无竞争情况下的同步操作，即一个线程使用的情况**。

偏，即锁会偏向第一个获取他的线程。没有其他线程竞争锁，则偏向锁永远不会同步：

1. 线程第一次获取锁对象，锁标志设置为`01`，使用CAS操作将线程ID写入mark word，成功则表示持有此偏向锁。
2. **另一个线程尝试获取锁时，<font color=red>偏向模式结束</font>，如果锁对象处于被锁定的状态，则膨胀为被轻量级锁锁定的状态，否则恢复无锁状态**
    - 另外一个线程通过检查是否存有指向当前线程id尝试获取锁，否的话查看对象锁是否是偏向的——正在被持有。


###### 轻量级锁

**在无竞争条件下CAS消除同步使用的互斥量。**对于绝大多数锁，其生命后期是不存在竞争的。

1. 在栈帧中拷贝一份mark word的数据；
2. jvm使用cas操作将mark word更新为指向 栈帧的指针，**成功则拥有了此对象监视器，并将锁标志位设置为00**；
3. 失败，则说明有竞争，**锁标志变为10，膨胀为重量级锁**











##### 1.引言

###### 1.1 简介
运输层提供了端到端（主机中的进程）的服务；网络层提供了主机到主机之间的服务；

一个运输层协议可能对应着多个应用层协议，因此它具备一个非常重要的功能 ==**复用(multiplexing)和分用(demultiplexing)**==:
- 复用multiplexing指发送方应用进程可以使用同一个传输层协议发送数据（加上适当的首部端口号）；
- 分用demultiplexing指接收方方的运输层去掉运输层协议的报文后将数据交给目的“应用进程”-根据去掉报文的端口；
- 示意图：
![](https://wx2.sinaimg.cn/mw690/006Xp67Kly1fpb2olcq6uj30ck0c9tb3.jpg)

传输成还需要提供差错检验——校验和；

运输层有两种协议：UDP（user datagram proportal）和TCP(transmission control portocol),其对应的应用层协议和应用一般如下（每个应用层协议也有自己默认的端口号）：
![](https://wx1.sinaimg.cn/mw690/006Xp67Kly1fpb2x2fe6tj30f30c4dgm.jpg)

###### 1.2 端口号（16位：65535）

运输层的multiplexing和demultiplexing功能需要对应用层的每个应用进程做唯一标识：
- 进程标识符不能作为标识，因为网络上种类繁多的计算机各有不同格式的进程标识符；
- 协议端口号 protocol port number简称prot端口：标识应用进程；
- 端口是软件端口，同硬件端口作区分；
- 端口号分源端口和目的端口：应用层的某种协议的请求目的端口需要用默认端口，但是源端口号随意。**源端口号只有本地意义，相同端口号没有关联**；

端口号分为两种：服务器端端口号和客户端端口号：
1. 服务器端端口号最重要的一类是熟知端口号（well-known port number)又称系统端口号，**0~1023**，IANA需要为每一种应用层协议制定一个熟知端口号，常用如下：
    - ![](https://wx4.sinaimg.cn/mw1024/006Xp67Kly1fpb4lsnlowj30ny02cmx5.jpg)
    - **1024~49151**：未登记的服务器端口号；
2. 客户端使用的端口号范围为**4915265535**，又称“短暂端口号”，请求报文中的源端口号；

##### 2. UDP用户数据报协议

UDP只在IP的数据报上增加了 复用/分用 和差错检测的功能，其主要特点有：
1. 无连接的：发送数据不需要建立连接；
2. UDP尽最大女里交付；
3. UDP面向报文的（TCP面向字节流），即UDP将应用层报文加上首部后就交给网络层，比拆分也不合并。面向字节流的TCP会在发送窗口中对应用层数据做拆分；使用UDP协议的应用层应该采用大小合适的报文，因为UDP将完整的报文交给IP层后，报文太大会拆分导致IP层效率不报，IP层太小导致首部相对较大也会降低传输效率；
4. UDP没有拥塞控制，即网络出现拥塞（congestion）不会使得源主机降低发送速率。TCP有相应的机制防止过多的数据出发送到网络中导致网络中路由器等节点过载；
5. **UDP支持一对一、一对多、多对一和多对多的交互通信**。TCP是面向连接的，因此只支持一对一；
6. UDP首部只有8个字节，TCP有20个字节并且有40字节的可选长度；

###### 2.1 首部格式及其差错检验和

UDP首部格式有四个字段，每个字段两个字节：源端口、目的端口、长度和检验和。格式如下：
![](https://wx1.sinaimg.cn/mw690/006Xp67Kly1fpb7tq50hrj30bk095glq.jpg)

- source port:如果不需要对方回信可全置为0；
- des port：标识应用进程。如果接收方UDP发现收到的报文中的端口号不正确即不存在，则会丢弃报文，并由ICMP发送“端口不可达”的差错报文给发送方；
- length：UDP用户数据包的长度，单位字节，最小值是只有头部是的8，最大值是2^16b-8b=2^6kb-8b=64kb-8bit；
- Checksum:有错则丢弃；

IP层的校验只校验数据报首部，但是UDP将首部和数据部分一块校验了，甚至包括了源IP和目的IP。校验方式如下：

1. 首先会在UDP首部前边加上伪首部，结构如下
![](https://wx2.sinaimg.cn/mw690/006Xp67Kly1fpb8p6go36j30bb050q2x.jpg)
2. **checksum初始值全0**；
3. 把伪首部和UDP数据报（包括数据部分）当做16位的01字串分割求和（不够16位则末尾补8个0）:**求和后进位的地方加到末尾**，最后求反码；
4. ==**接收端，同上求和、高位补低位、取反，**== ==**最后结果如果全为1则视为正确**== ；

[注]
- “n个数求和取反”=校验码，“n个数+校验码”求和取反=校验码+校验码取反=1；
- TCP使用同样的校验方式；


